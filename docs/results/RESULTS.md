ICFP 2015 Stanfy+ Team Отчет
=========
Тут я, як і в кожній статті про [ICFP Contest][2] просто маю сказати, про те, що це щорічне змагання, яке проводиться в рамках [ICFP Conference][1]. Дуже детально про нього написано на [вікіпедії][3]. В цілому - кожен рік нова задача, на 72 години. Кількість людей в команді не обмежена, на мову програмування обмеження також відсутні*. Тобто, є можливість на 72 години поринути у світ задачі, яку видумали цього року організатори і повернутися з купою вражень. Звичайно, якщо такі речі вас цікавлять. Від себе додам, що для людей, які вперше про це чують, я рекомендую прочитати [звіт adept'а][4] про участь у ICFP Contest 2006 року. Цей звіт є своєрідною класикою. І саме, прочитавши цей звіт мені захотілося прийняти участь в цьому змаганні.

Готуймося!
=====
Кожного року, ми на роботі придумуємо, на якій мові програмування, ми будемо виконувати завдання. І кожного разу після тривалих суперечок ми зупиняємося на Java. Ну виходить так ;) Цей рік не був виключенням, і на Javа'і довелося попрограмувати, але, як виявилося потім, не тільки на ній.


Перший день (П’ятниця) (Старт Змагання о 15:00)
====
На роботі як раз в цей час був невеличкий аврал у всіх учасників змагання, через що почали ми читати завдання тільки об 18:00 і пізніше. Завдання, до речі, виявилося досить об’ємним, і включало в себе 27 сторінок А4. Більшість з яких були захаращені документацію стосовно інструкцій різних процесорів, але все одно, не мало.

Завдання
---
Для того, щоб виграти цього року, необхідно було написати програму для Lambda-Man'a, який ма тікати від привидів по полю, на якому крім них є пігулки, великі пігулки, фрукти... і ось мабуть усе. З’ївши велику пігулку, розташовану на карті, LMan отримує можливість обмежений час ласувати привидами без усіляких столових приборів. За будь які позитивні для LManа дії, він отримує відповідну кількість балів

    - пігулка - 10 балів
    - велика пігулка - 50 балів
    - привид - 200-1600 балів
    - фрукти - 100-5000 балів

![мапа](http://habrastorage.org/files/7b1/f0e/1ad/7b1f0e1ad47d4f6bb53f24c5280defea.png)

Якщо ви знайомі з старими класичними іграми давнини, то, одразу зрозуміли, що мова йде про [Pac-Man'a][5]

Тобто для виконаня завдання, необхідно було створити алгоритм дій PacMan'а.... написаний на асемблері для Lambda-Man CPU.
"Забудьте свою улюблену мову програмування на 72 години! Ви будете писати на асемблері наступні 3 доби!".

Lambda-Man CPU
---
Процесор Lambda-Man'а виявився трохи дивним. 
Він складався з 4 регістрів, до яких ми не мали прямого доступу, 3 стеків, і 27 команд. 
Не те, щоб я перший раз чув про процесор такого типу, але програмувати під нього мені точно ніколи не доводилося.
Ось приклад нескладної програми, яка викликає функцію з одним параметром для LMCPU

```
Minimal example of creating and using a local variable.

  LDC  21
  LDF  body     ; load body
  AP   1        ; call body with 1 variable in a new frame
  RTN
body:
  LD   0 0      ; var x
  LD   0 0      ; var x
  ADD
  RTN
```

19:56 (4 години після старту)
---
Ми робимо перші загальні збори нашої команди, і вирішуємо наступне

    - Ми будемо писати програму на мові високого рівня, яка буде компалюватися після в LMCPU
    - Один з нас займеться задачею збірки результуючого завдання
    - Мова високого рівня, на якій ми будемо писати - буде Clojure
    - Писати власну реалізаію процессора - не будемо, через те, що організатори дали можливість випробовувати наші програми у їх реалізації, написаній на JS
   
Clojure
---    
Чому, власне саме Clojure? Це питання я задавав собі не один раз на цьому змаганні. Основною ідеєю було те, що асебмлер для LMCPU був спеціально придуманий для того, щоб його легко було компілювати з функціональної мови Lisp. Для генерації комілятора, ми використовуємо [ANTLR][6], і Lisp'a відповідної граматики, з якою міг працювати ANTLR, ми не знайшли. Найближчою мовою зі схожим записом, виявився [Clojure][7].


21:18 (6 Годин після старту)
----
У нас є напівавтоматична збірка нашого завдання для подальшої відсилки для заліку
Рома[100] працює над свторенням компілятору з Clojure* 
[Я][101] і [Паша][102] розбираємося з асемблером і копирасаємося в HTML + JS, що надали організатори.

Неприємною для наснесподіванкою виявилося, що мітки, які були використані в прикладах на сайті не працюють ;(
Тому довелося трохи підправити JS, ввевши туди додаткові константи, і мітки

*Before*
```
LDC  0
LDF  4
CONS
RTN

LDC  0
LDC  1
CONS

RTN
```

*After*
```
LDC  0
LDF  step_function
CONS
RTN
 
step_function:
LDC  0
LDC  DIRECTION_UP
CONS

RTN
```

крім того, [Міша][104] і всі інші взялися швиденько вчити Closure, для того, щоб до часу, коли в нас буде компілятор, ми б могли написати хоч щось на Clojure. Вчилися ми за допомогою сайту [Clojure Koans][8]


23:30 (8 Годин після старту)
-----
У нас є розпарсене дерево Clojure by [Рома][100]

01:00 (10 годин після старту)
-----
/me оцінив швидкість, з якою ми опановуємо Clojure, і зрозумів, що з такими темпами нам нічого не світить ;( 
Ну зовсім не світить. Можливо, це моє власне ставлення до того, що відбувалося, але мій мозок відмовився від ідеї писати на Clojure, і захотів писати на чомусь ближчому для мене і зрозумілішому ;) Наприклад, на ECMAScript (а-ка JavaScript).
Крім цього на даному етапі було вже зрозуміло, що
    - мова високого рівня, на якій ми будемо писати, не зовсім буде Clojure
    - будья яка мова високого рівня, яку ми напишемо, буде дуже віддалено нагадувати мову, граматику якої вона використовує
    
02:34 (11,5 годин після старту)
-----
[Паша][102] опатовує команду DBUG процесора, і, нарешті ми бачимо в якому вигляді нам будуть приходити дані  
LMan state

```
 (0, ((11, 16), (2, (3, 0))))
```

Ghosts state
```
((0, ((11, 8), 2)), ((0, ((10, 10), 2)), ((0, ((11, 10), 2)), ((0, ((12, 10), 2)), 0))))
```

Карта:

```
((0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, (0, 0))))))))))))))))))))))), ((0, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (0, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (0, 0))))))))))))))))))))))), ((0, (2, (0, (0, (0, (2, (0, (0, (0, (0, (2, (0, (2, (0, (0, (0, (0, (2, (0, (0, (0, (2, (0, 0))))))))))))))))))))))), ((0, (3, (0, (0, (0, (2, (0, (0, (0, (0, (2, (0, (2, (0, (0, (0, (0, (2, (0, (0, (0, (3, (0, 0))))))))))))))))))))))), ((0, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (2, (0, 0))))))))))))))))))))))), ((0, (2, (0, (0, ...
```


02:10
-----
Мій компалятор з ECMAScript почав давати перші ознаки життя, 
```
var f = 2; f++;
var b = 5;
var c = f + b;
```

і тут я зрозумів, що простої перевірки "що саме він генерує", мені не вистачить. Звичайно, я міг кожного разу перевіряти асемблер, що був згенерований прямо в HTML, від організаторів, але цього було замало, і це було не достатьно швидко. Тим паче, що зламати щось було дуже легко, і кожен раз проводити тести на генерацію руками, не є доцільним.

Саме тому я вирішив, що в тестах я буду використовувати не стільки асебмлер, який має згенеруватися, а стан процесора після виконання програми.

Години дві я провів у пошуках бібліотеки на Java, яка була б здатна включити і виконати JavaScript організаторів. Але всі Java бібліотеки відмовлялися завантажувати і виконувати той man.js розміром 3,3Mb. Всі вони падали з помилкою "Code is too Large". 

Інтеграція тестів з браузером мені теж здалася не дуже вдалою ідеєєю, і тому я вирішив написати емулятор LMan CPU.

05:43
----
Більшість команд процесора - була земульована, і, коли дехто тільки-тільки почав прокидатися я пішов, нарешті спати.

Другий день (Субота)
====
Поки я ще сплю, [Рома][100] продовжує писати компілятор Clojure.
Одна за одною додаються команди, і тести для компілятора виглядають приблизно наступним чином
```
test(
    "(+ 2 4)",

    "LDC 2\n",
    "LDC 4\n",
    "ADD"
    );

```

10:15
---
Прокидаюсь я, підключаюсь, і розумію, що упустив той момент, що у разі невиконання, або неправильного формата інструкції, або значен на стекових регістрах, процесор має впадати в кататонію. Швиденько виправляюсь, вводячи поступово перевірки для типів даних, що використовуються.

В той. час, як [Міша][104] захворіва, не витримавши сидіння під кондиціонером у люту спеку, приходить [Настя][103], і допомагає мені добити всі інструкціі процесора, з помилковими станами.
[Паша][102] в цей час сидить і рзбирає структури даних на асемблері

12:46
----
Наш процесор, нарешті вміє повністю емулювати всі необхідні нам інструкції, і перший тест це наглядно показує
```
    //(> (+ (- 3 1) (* 2 2)) (== 2 2))

    ArrayList<LambdaManProcessorInstruction> instructions =
        LambdaManProcessor.parseAsmProgram(
                "LDC 3\n"+
                "LDC 1\n"+
                "SUB\n"+
                "LDC 2\n"+
                "LDC 2\n"+
                "MUL\n"+
                "ADD\n"+
                "LDC 2\n"+
                "LDC 2\n"+
                "CEQ\n"+
                "CGT");

    processor = new LambdaManProcessor(instructions);
    processor.run();

    assert(processor.topStackValue().equals(1)); // result of expression

```
Ии у захваті від виконаної роботи, доповідаємо Ромі, що тепер можна результати компіляції програм з Clojure можна скармлювати емулятору процесора, і перевіряти правильність стану процесора.
Це додало на впевненості в тому, що тепер, прорами, які ми пишемо, за умови перевірки емуляції на нашому процесорі, будуть нормально виконуватися і на процесорі організаторів.

Скооперувавшися з [Пашею][102], ми перевіряємо програми, які вже він встиг написати на нашому процесорі. Все працює!

13:21
---
Розуміючи, що ми зовсім не встигаємо нічого написати на Clojure, швидко перемикаємося на чистий асебмлер, і намагаємося, разом з [Пашею][102] написати, хоч щось, що буде вміти ходити по карті

14:25
---
Перше завантаження нашого LMan'а, який просто спокійно іде собі в одну сторону.

14:28
---
Заватнажуємо LMan'а, який має ходити за правилом правої руки по лабіринту, не зважаючи ні на що.   
Як не прикро, але помилка при обрахуванні наступного напряму, призвела до того, що ми ламали гру. Ми дуже засмутилися, що при 0(вгору), 1(вправо), 2(вниз), 3(вліво), гра не знала такого напрямку як 4 ;)
В результаті наше рішення на Lighting Round (перші 24 години) було кволим, і навряд чи набере будь яку кількість балів.

15:00
-----
Поки організатори викладають додаткове завдання для управління привидами, у нас обідня перерва.

16:15
-----
В додатковому завданні від організаторів, додається умова, що додатково, крім алгоритму для LMan'у, нам потрібно ще буде відсилати алгоритми для привидів (до 4х алгоритмів). І ці алгоритми мають бути також написані на асебмлері.
![ghost-thinking](http://habrastorage.org/files/ad4/1ab/70b/ad41ab70b0dd4be59f1d083b5d513115.jpg)

Тільки з деякими обмеженнями,так, наприклад асемблер для процесора, на якому виконуються програми привидів зовсім інший. Більш схожий на x86 процесор. Крім того, максимальна кількість команд для алгоритму привида не повинна перевищувати 256 команд, що в цілому дуже мало як для асемблера.

Тут ми вирішили Розділитися, і [Паша][102] з [Настєю][103] пішли вправляти мізки привидам, а ми з [Ромою][100] та Олєгом, почали ускладнювати собі життя.

Function Environment Problem
---
Суть проблеми, з якою ми зіткнулися була приблизно ось яка:
Змінні, які передаються у фукнцію, завжди зберігаються у так званому оточенні (Envorinment, або ENV)
Тобто, кожна функція може доступатися до своїх змінних за допомогою ENV.  
Ось приблизно так:  
![example](http://habrastorage.org/files/56a/fce/6e7/56afce6e74b844e4870125398845c451.jpg)  
І компілятор, зустрічаюючи якусь змінну, має перетворювати доступ до цієї змінної на доступ до ENV за конкретною адресою
При чому, першим параметром - є т.з. глибина оточення - Своє оточення - завжди має значення 0, батьківське оточення - 1, і т. далі.
Ось приблизно таким чином:  
![exmple2](http://habrastorage.org/files/c2d/aa4/2c9/c2daa42c977347bd97831d7b8261041e.jpg)  
Тобто, використання x, y у функції first, має траслюватися в ENV[0,0], ENV[0,1]. А от, використання ціх же самих змінних у функції second, вже буде виглядати як  ENV[1,0], ENV[1,1].

В принципі в генерації такого коду немає ніяких проблем. При коміляції, бачимо рівень функції, і підставляємо необхідне значення. Такий код досить легко генерується.

Проблеми виникають тоді, коли ми використовуємо рекурсивний виклик.  
![example3](http://habrastorage.org/files/e52/6d8/a6e/e526d8a6e0954656915821f6c825c672.jpg)  
Як бачимо, доступ до одних і тих же змінних з батьківського оточення, має транслюватися у різні команди.

Ось над цією проблемою ми і засіли надовго. На дуже довго.
Більш того, наше бурхливе "обговорення" того, що нам, насамперед, потрібно, призвело до того, що [Рома][100] втік до іншої кімнати :)

18:05
-----
Наша перша програма на Clojure*, яка в результаті давала можливість LMan'у просто йти праворуч
```
(defn step [state world] (tuple (0 1)))
(defn main [world anything] (tuple (0 step)))
```
[Паша][102] і [Настя][103] активно створювали щось на зразок макроассебмлера для асебмлера привидів.
Інші продовжують думати над проблемою і додатково час від часу пишуть тести для Clojure'.  

Скоро з’являються оператори типу if і основні функціі для роботи зі списками first, last, nth

21:00
____
Після початку активного створення програм на Clojure, довелося прикручувати інструкцію DBUG, яка виводила значення в стку на екран. Головною "проблемою" цієї функцію було те, що вона "знімала" значення з гори стеку, руйнуючи логіку роботи програми. Але і цю проблему було вирішено. До речі, до того, як ця функція була зроблена, я дивився на результати роботи алгоритму за напрямком, у якойму йшов LMan:)  
```
(defn dbg [fn]
  (first (tuple (
                  fn
                  (DBG fn)
                )
          ))
  )
  
```

Активно практикуємося в написанні функцій на Clojure'  
```
(defn nextCellByCurrentDirection2 [world direction location]
  (if (== direction 0)
    (decy location)
    (if (== direction 1)
      (incx location)
      (if (== direction 2)
        (incy location)
        (if (== direction 3)
          (decx location)
          (manLocation world)
          )
        )
      )
    )
  )

(defn nextCellByCurrentDirection [world]
  (nextCellByCurrentDirection2 (manDirection world) (manLocation world))
  )
```

Досить великою проблемою стало те, що для обчислення даних, треба "прокидувати" додаткові параметри з верзнього рівня на нижній. Це призводило до того, що змінна world, була чи не у всіх функціях.


23:30
----
У нас нарешті з’являється перший алгоритм для LMan'а, який може рухатися за правилом правої, чи лівою руки. Це було не дуже багато, і привиди Насті і Паші нас швиденько ловили, але це вже було хоч щось.

Третій день (Неділя)
====
В цю ніч мені снилися кляті скобки. Я розумів, що Clojure, це звичайно функціональна мова, і таке інше, і для того, щоб нам зробити якого-небудь більш-менш нормального LMan'a нам треба буде саме на цій мові написати алгоритм, тим паче, що Рома додав додаткову фунцію let, яка дуже сильно скорочувала записи деяких функцій.
Рома, навіть почав писати тести на самому Clojure'і ;) Засів за реалізацію [A-Star][9]
Крім того, додалося багато додаткових функцій типу Filter, map, find, які були необхідні для реалізації A-Star алгоритму.

Але з алгоритмом LMan'а не складалося.

Мої потуги з написання хвильового алгоритму на Clojure'залишилися ні з чим, і я здався ;)   
О 17:30 останнього дня засів за компілятор для ECMAScript'

Javascript Run
---
    - 18:37 Додана обробка +,-,DIV,MUL,),( у JavasScript
    - 20:32 Обробка функцій, параметрів у функціі, використання функцій за посиланням
    - 22:53 Функції порівняння, та if
    - 28.07
    - 00:21 Змінні! Ось чого мені не вистачало у Clojure'! Змінні!
    - 01:36 Перший бот на JavaScript
    - 03:01 Бот, що ходить за правилом лівої руки
    - 07:02 Базовий хвильовий алгоритм, що шукав всі пігулки або фрукти
    - 08:24 прискорений трохи алгоритм, який, нарешті зміг пройти базову карту
    - ~~:~~ zzz-zzz-z-z

Четвертий день (Понеділок)
====
Зранку, Паша скооперувався з Ромою, і вони продовжили реалізовувати A* на Clojure'.
Настя, прогнала рішення на JS на декількох картах, і виявилося, що на деяких з них, ми навіть можемо вигравати, але з малою кількістю балів.

14:00
----
Прокинувшись, о 13:00 я порадів за наш алгоритм, і побіг вправляти мозок нашомо LMan'у, для того, щоб він не помирав від привидів при любій слушній нагоді.
В першу чергу, ми додали трошки логіки, щоб, у разі чого, рахувати привидів як стіну, при обрахуванні алгоритму. Це дозволило LManу не помирати так часто.
Крім того, у разі, якщо LMan з’їдав велику пігулку, він переставав вважати привидів за перепони, і незважав на них взагалі. 
Була, звичайно, ідея ганятися за привидами, у разі поїдання великої пігулки, але виявилося, що в цьому разі, LMan помирав набагато частіше ;)

14:53
----
[Відео, як ми Ми відправляємо наше рішення][10].


Результати
====
Багато емоцій ;)  
Трошки, звичайно засмучені, що не вдалося написати більше :)  
Навряд чи наш LMan займе якесь призове місце ;)   

Тести! Тести-тести-тести-тести!  
У таких змаганнях, коли багато чого змінються і час від часу одні люди змінюють інших на одній ті самій задачі, тести - допомогають розуміти, в якому стані знаходиться ваш код.  

З мінусів - це те, що ми все-таки написали 2 компілятора замість одного ;) І взагалі розділилися на дві гілки рішення однієї задачі.  

В цілому - весело, але виснажливо ;)  
В наступному році - я точно буду приймати участь ще раз.


[1]:http://icfpconference.org/
[2]:http://icfpcontest.org
[3]:http://en.wikipedia.org/wiki/ICFP_Programming_Contest
[4]:http://users.livejournal.com/_adept_/24049.html
[5]:http://ru.wikipedia.org/wiki/Pac-Man
[6]:http://www.antlr.org/
[7]:http://clojure.org/lisps
[8]:http://clojurekoans.com/
[9]:http://uk.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%BF%D0%BE%D1%88%D1%83%D0%BA%D1%83_A*
[10]:https://www.youtube.com/watch?v=ubkl39zNHy4
[100]:https://github.com/roman-mazur
[101]:https://github.com/PaulTaykalo
[102]:https://github.com/bexcite
[103]:https://github.com/vixentael
[104]:https://github.com/lampapos








