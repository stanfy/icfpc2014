; ghost-functions

; ------------------------- 
; calculate path score from cell1 to cell2 
; in:
; 240(x1), 241(y1), 250(x2), 251(y2)
; out:
; path score in A
FN_PATH_SCORES_BETWEEN_CELLS:

mov a, [240]   ; X1 ---> a
sub a, [250]   ; X1 - X2
jgt FN_PATH_OK_1, [240], [250]
mov a, [250]
sub a, [240]

FN_PATH_OK_1:
;add a, 1       ; +1 as solution for rounding
div a, 2       ; (X1 - X2) / 2

mov b, [241]   ; Y1 ---> b
sub b, [251]   ; X1 - X2
jgt FN_PATH_OK_2, [241], [251]
mov b, [251]
sub b, [241]

FN_PATH_OK_2:
;add b, 1       ; +1 as solution for rounding
div b, 2       ; (Y1 - Y2) / 2

add a, b       ; path scores

RETURN

; ------------------------- 
; get cell content
; in:
; 240(direction)
; out:
; cell content in A
; cell -- 240(x), 241(y)
FN_CONTENT_CELL_ON_DIRECTION:

; Save current ghost direction
int 3          ; ghost index --> A
int 5          ; x ---> A, y ---> B

mov c, [240]   ; direction --> C

jeq PATH_UP, c, DIRECTION_UP
jeq PATH_RIGHT, c, DIRECTION_RIGHT
jeq PATH_DOWN, c, DIRECTION_DOWN
jeq PATH_LEFT, c, DIRECTION_LEFT

PATH_UP:
sub b, 1       ; Y-1
jeq JUMP_P, 1, 1

PATH_RIGHT:
add a, 1       ; X+1
jeq JUMP_P, 1, 1

PATH_DOWN:
add b, 1       ; Y+1
jeq JUMP_P, 1, 1

PATH_LEFT:
sub a, 1       ; X-1
jeq JUMP_P, 1, 1

JUMP_P:
mov [240], a
mov [241], b
int 7		   ; A (X-1), B(Y) --> CONTENT
RETURN


; -------------------------  SELECT DESTINATION
; in:
; [0] - REG_STATE
; [1] - REG_CNT
; [2] - REG_NC (next corner)
; [3] - REG_FR (first run)
;
; [10] - REG_DEST_CELL_X
; [11] - REG_DEST_CELL_Y
;
; out:
; dest cell coordinates in REG_DEST_CELL_X, REG_DEST_CELL_Y
;
; [0] --- current state
;  == 0 -- moving to LM
;  == 1 -- moving to Corner 1
;  == 2 -- moving to Corner 2
;  == 3 -- moving to Corner 3
;  == 4 -- moving to Corner 4

; [1] --- counter
; [2] --- next Corner  0, 1, 2, 3
;
;  10 --- steps to Corner
;  20 --- steps to LM

FN_SELECT_DESTINATION:

; ---- check counter
mov a, REG_STATE
mov b, REG_CNT
mov c, REG_NC
jeq ZERO_COUNTER, REG_CNT, 0       ; check counter
sub REG_CNT, 1					   ; counter > 0
jeq CHECK_STATE, 1, 1

; ---- counter == 0
ZERO_COUNTER:
jeq ZERO_STATE, REG_STATE, 0 ; check state
mov REG_STATE, 0
mov REG_CNT, 20              ; TODO: move 20 to constant
jeq CHECK_STATE, 1, 1

ZERO_STATE:
inc REG_NC
mov REG_STATE, REG_NC
and REG_NC, 3
mov REG_CNT, 7               ; TODO: move 7 to constant
jeq CHECK_STATE, 1, 1


; ---- counter > 0
CHECK_STATE:
jeq RUN_TO_LM,REG_STATE, 0    ; move to LM
jeq RUN_TO_CORNER_1, REG_STATE, 1 
jeq RUN_TO_CORNER_2, REG_STATE, 2 
jeq RUN_TO_CORNER_3, REG_STATE, 3 
jeq RUN_TO_CORNER_4, REG_STATE, 4 


; ------------------------ MOVING TO LM
RUN_TO_LM:
int 1		   ; LM coordinate
mov REG_DEST_CELL_X, A	   ; LM x
mov REG_DEST_CELL_Y, B     ; LM y
jeq START_MOVING, 1, 1

; ------------------------ MOVING TO CORNER 1
RUN_TO_CORNER_1:
mov REG_DEST_CELL_X, 0	   
mov REG_DEST_CELL_Y, 0    
jeq START_MOVING, 1, 1

; ------------------------ MOVING TO CORNER 2
RUN_TO_CORNER_2:
mov REG_DEST_CELL_X, 0	   
mov REG_DEST_CELL_Y, 255  
jeq START_MOVING, 1, 1

; ------------------------ MOVING TO CORNER 3
RUN_TO_CORNER_3:
mov REG_DEST_CELL_X, 255	   
mov REG_DEST_CELL_Y, 0 
jeq START_MOVING, 1, 1

; ------------------------ MOVING TO CORNER 4
RUN_TO_CORNER_4:
mov REG_DEST_CELL_X, 255	   
mov REG_DEST_CELL_Y, 255   
jeq START_MOVING, 1, 1

START_MOVING:
RETURN

hlt
